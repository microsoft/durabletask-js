// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

import * as grpc from "@grpc/grpc-js";
import { StringValue, Int32Value } from "google-protobuf/google/protobuf/wrappers_pb";
import { Timestamp } from "google-protobuf/google/protobuf/timestamp_pb";
import * as pb from "../proto/orchestrator_service_pb";
import * as stubs from "../proto/orchestrator_service_grpc_pb";
import { TOrchestrator } from "../types/orchestrator.type";
import { TInput } from "../types/input.type";
import { getName } from "../task";
import { randomUUID } from "crypto";
import { newOrchestrationState } from "../orchestration";
import { OrchestrationState } from "../orchestration/orchestration-state";
import { GrpcClient } from "./client-grpc";
import { OrchestrationStatus, toProtobuf } from "../orchestration/enum/orchestration-status.enum";
import { TimeoutError } from "../exception/timeout-error";
import { PurgeResult } from "../orchestration/orchestration-purge-result";
import { PurgeInstanceCriteria } from "../orchestration/orchestration-purge-criteria";
import { EntityInstanceId } from "../entities/entity-instance-id";
import { EntityMetadata, createEntityMetadata, createEntityMetadataWithoutState } from "../entities/entity-metadata";
import { EntityQuery } from "../entities/entity-query";
import { SignalEntityOptions } from "../entities/signal-entity-options";
import {
  CleanEntityStorageRequest,
  CleanEntityStorageResult,
  defaultCleanEntityStorageRequest,
} from "../entities/clean-entity-storage";

import { callWithMetadata, MetadataGenerator } from "../utils/grpc-helper.util";

// Re-export MetadataGenerator for backward compatibility
export { MetadataGenerator } from "../utils/grpc-helper.util";

export class TaskHubGrpcClient {
  private _stub: stubs.TaskHubSidecarServiceClient;
  private _metadataGenerator?: MetadataGenerator;

  /**
   * Creates a new TaskHubGrpcClient instance.
   *
   * @param hostAddress The host address to connect to. Defaults to "localhost:4001".
   * @param options gRPC channel options.
   * @param useTLS Whether to use TLS. Defaults to false.
   * @param credentials Optional pre-configured channel credentials. If provided, useTLS is ignored.
   * @param metadataGenerator Optional function to generate per-call metadata (for taskhub, auth tokens, etc.).
   */
  constructor(
    hostAddress?: string,
    options?: grpc.ChannelOptions,
    useTLS?: boolean,
    credentials?: grpc.ChannelCredentials,
    metadataGenerator?: MetadataGenerator,
  ) {
    this._stub = new GrpcClient(hostAddress, options, useTLS, credentials).stub;
    this._metadataGenerator = metadataGenerator;
  }

  async stop(): Promise<void> {
    await this._stub.close();

    // Wait a bit to let the async operations finish
    // https://github.com/grpc/grpc-node/issues/1563#issuecomment-829483711
    await new Promise((resolve) => setTimeout(resolve, 1000));
  }

  /**
   * Schedules a new orchestrator using the DurableTask client.
   *
   * @param {TOrchestrator | string} orchestrator - The orchestrator or the name of the orchestrator to be scheduled.
   * @return {Promise<string>} A Promise resolving to the unique ID of the scheduled orchestrator instance.
   */
  async scheduleNewOrchestration(
    orchestrator: TOrchestrator | string,
    input?: TInput,
    instanceId?: string,
    startAt?: Date,
  ): Promise<string> {
    let name;
    if (typeof orchestrator === "string") {
      name = orchestrator;
    } else {
      name = getName(orchestrator);
    }
    const req = new pb.CreateInstanceRequest();
    req.setName(name);
    req.setInstanceid(instanceId ?? randomUUID());

    const i = new StringValue();
    i.setValue(JSON.stringify(input));

    const ts = new Timestamp();
    ts.fromDate(new Date(startAt?.getTime() ?? 0));

    req.setInput(i);
    req.setScheduledstarttimestamp(ts);

    console.log(`Starting new ${name} instance with ID = ${req.getInstanceid()}`);

    const res = await callWithMetadata<pb.CreateInstanceRequest, pb.CreateInstanceResponse>(
      this._stub.startInstance.bind(this._stub),
      req,
      this._metadataGenerator,
    );

    return res.getInstanceid();
  }

  /**
   * Fetches orchestrator instance metadata from the configured durable store.
   *
   * @param {string} instanceId - The unique identifier of the orchestrator instance to fetch.
   * @param {boolean} fetchPayloads - Indicates whether to fetch the orchestrator instance's
   *                                       inputs, outputs, and custom status (true) or omit them (false).
   * @returns {Promise<OrchestrationState | undefined>} A Promise that resolves to a metadata record describing
   *                                              the orchestrator instance and its execution status, or undefined
   *                                              if the instance is not found.
   */
  async getOrchestrationState(
    instanceId: string,
    fetchPayloads: boolean = true,
  ): Promise<OrchestrationState | undefined> {
    const req = new pb.GetInstanceRequest();
    req.setInstanceid(instanceId);
    req.setGetinputsandoutputs(fetchPayloads);

    const res = await callWithMetadata<pb.GetInstanceRequest, pb.GetInstanceResponse>(
      this._stub.getInstance.bind(this._stub),
      req,
      this._metadataGenerator,
    );

    return newOrchestrationState(req.getInstanceid(), res);
  }

  /**
   * Waits for a orchestrator to start running and returns a {@link OrchestrationState} object
   * containing metadata about the started instance, and optionally, its input, output,
   * and custom status payloads.
   *
   * A "started" orchestrator instance refers to any instance not in the Pending state.
   *
   * If a orchestrator instance is already running when this method is called, it returns immediately.
   *
   * @param {string} instanceId - The unique identifier of the orchestrator instance to wait for.
   * @param {boolean} fetchPayloads - Indicates whether to fetch the orchestrator instance's
   *                                  inputs, outputs (true) or omit them (false).
   * @param {number} timeout - The amount of time, in seconds, to wait for the orchestrator instance to start.
   * @returns {Promise<OrchestrationState | undefined>} A Promise that resolves to the orchestrator instance metadata
   *                                               or undefined if no such instance is found.
   */
  async waitForOrchestrationStart(
    instanceId: string,
    fetchPayloads: boolean = false,
    timeout: number = 60,
  ): Promise<OrchestrationState | undefined> {
    const req = new pb.GetInstanceRequest();
    req.setInstanceid(instanceId);
    req.setGetinputsandoutputs(fetchPayloads);

    try {
      const callPromise = callWithMetadata<pb.GetInstanceRequest, pb.GetInstanceResponse>(
        this._stub.waitForInstanceStart.bind(this._stub),
        req,
        this._metadataGenerator,
      );

      // Execute the request and wait for the first response or timeout
      const res = (await Promise.race([
        callPromise,
        new Promise((_, reject) => setTimeout(() => reject(new TimeoutError()), timeout * 1000)),
      ])) as pb.GetInstanceResponse;

      return newOrchestrationState(req.getInstanceid(), res);
    } catch (e) {
      console.log(e);
      throw e;
    }
  }

  /**
   * Waits for a orchestrator to complete running and returns a {@link OrchestrationState} object
   * containing metadata about the completed instance, and optionally, its input, output,
   * and custom status payloads.
   *
   * A "completed" orchestrator instance refers to any instance in one of the terminal states.
   * For example, the Completed, Failed, or Terminated states.
   *
   * If a orchestrator instance is already running when this method is called, it returns immediately.
   *
   * @param {string} instanceId - The unique identifier of the orchestrator instance to wait for.
   * @param {boolean} fetchPayloads - Indicates whether to fetch the orchestrator instance's
   *                                  inputs, outputs (true) or omit them (false).
   * @param {number} timeout - The amount of time, in seconds, to wait for the orchestrator instance to start.
   * @returns {Promise<OrchestrationState | undefined>} A Promise that resolves to the orchestrator instance metadata
   *                                               or undefined if no such instance is found.
   */
  async waitForOrchestrationCompletion(
    instanceId: string,
    fetchPayloads: boolean = true,
    timeout: number = 60,
  ): Promise<OrchestrationState | undefined> {
    const req = new pb.GetInstanceRequest();
    req.setInstanceid(instanceId);
    req.setGetinputsandoutputs(fetchPayloads);

    try {
      console.info(`Waiting ${timeout} seconds for instance ${instanceId} to complete...`);

      const callPromise = callWithMetadata<pb.GetInstanceRequest, pb.GetInstanceResponse>(
        this._stub.waitForInstanceCompletion.bind(this._stub),
        req,
        this._metadataGenerator,
      );

      // Execute the request and wait for the first response or timeout
      const res = (await Promise.race([
        callPromise,
        new Promise((_, reject) => setTimeout(() => reject(new TimeoutError()), timeout * 1000)),
      ])) as pb.GetInstanceResponse;

      const state = newOrchestrationState(req.getInstanceid(), res);

      if (!state) {
        return undefined;
      }

      let details;

      if (state.runtimeStatus === OrchestrationStatus.FAILED && state.failureDetails) {
        details = state.failureDetails;
        console.info(`Instance ${instanceId} failed: [${details.errorType}] ${details.message}`);
      } else if (state.runtimeStatus === OrchestrationStatus.TERMINATED) {
        console.info(`Instance ${instanceId} was terminated`);
      } else if (state.runtimeStatus === OrchestrationStatus.COMPLETED) {
        console.info(`Instance ${instanceId} completed`);
      }

      return state;
    } catch (e) {
      console.log(e);
      throw e;
    }
  }

  /**
   * Sends an event notification message to an awaiting orchestrator instance.
   *
   * This method triggers the specified event in a running orchestrator instance,
   * allowing the orchestrator to respond to the event if it has defined event handlers.
   *
   * @param {string} instanceId - The unique identifier of the orchestrator instance that will handle the event.
   * @param {string} eventName - The name of the event. Event names are case-insensitive.
   * @param {any} [data] - An optional serializable data payload to include with the event.
   */
  async raiseOrchestrationEvent(instanceId: string, eventName: string, data: any = null): Promise<void> {
    const req = new pb.RaiseEventRequest();
    req.setInstanceid(instanceId);
    req.setName(eventName);

    const i = new StringValue();
    i.setValue(JSON.stringify(data));

    req.setInput(i);

    console.log(`Raising event '${eventName}' for instance '${instanceId}'`);

    await callWithMetadata<pb.RaiseEventRequest, pb.RaiseEventResponse>(
      this._stub.raiseEvent.bind(this._stub),
      req,
      this._metadataGenerator,
    );
  }

  /**
   * Terminates the orchestrator associated with the provided instance id.
   *
   * @param {string} instanceId - orchestrator instance id to terminate.
   * @param {any} output - The optional output to set for the terminated orchestrator instance.
   */
  async terminateOrchestration(instanceId: string, output: any = null): Promise<void> {
    const req = new pb.TerminateRequest();
    req.setInstanceid(instanceId);

    const i = new StringValue();
    i.setValue(JSON.stringify(output));

    req.setOutput(i);

    console.log(`Terminating '${instanceId}'`);

    await callWithMetadata<pb.TerminateRequest, pb.TerminateResponse>(
      this._stub.terminateInstance.bind(this._stub),
      req,
      this._metadataGenerator,
    );
  }

  async suspendOrchestration(instanceId: string): Promise<void> {
    const req = new pb.SuspendRequest();
    req.setInstanceid(instanceId);

    console.log(`Suspending '${instanceId}'`);

    await callWithMetadata<pb.SuspendRequest, pb.SuspendResponse>(
      this._stub.suspendInstance.bind(this._stub),
      req,
      this._metadataGenerator,
    );
  }

  async resumeOrchestration(instanceId: string): Promise<void> {
    const req = new pb.ResumeRequest();
    req.setInstanceid(instanceId);

    console.log(`Resuming '${instanceId}'`);

    await callWithMetadata<pb.ResumeRequest, pb.ResumeResponse>(
      this._stub.resumeInstance.bind(this._stub),
      req,
      this._metadataGenerator,
    );
  }

  /**
   * Purges orchestration instance metadata from the durable store.
   *
   * This method can be used to permanently delete orchestration metadata from the underlying storage provider,
   * including any stored inputs, outputs, and orchestration history records. This is often useful for implementing
   * data retention policies and for keeping storage costs minimal. Only orchestration instances in the
   * `Completed`, `Failed`, or `Terminated` state can be purged.
   *
   * If the target orchestration instance is not found in the data store, or if the instance is found but not in a
   * terminal state, then the returned {@link PurgeResult} will report that zero instances were purged.
   * Otherwise, the existing data will be purged, and the returned {@link PurgeResult} will report that one instance
   * was purged.
   *
   * @param value - The unique ID of the orchestration instance to purge or orchestration instance filter criteria used
   * to determine which instances to purge.
   * @returns A Promise that resolves to a {@link PurgeResult} or `undefined` if the purge operation was not successful.
   */
  async purgeOrchestration(value: string | PurgeInstanceCriteria): Promise<PurgeResult | undefined> {
    let res;
    if (typeof value === `string`) {
      const instanceId = value;
      const req = new pb.PurgeInstancesRequest();
      req.setInstanceid(instanceId);

      console.log(`Purging Instance '${instanceId}'`);

      res = await callWithMetadata<pb.PurgeInstancesRequest, pb.PurgeInstancesResponse>(
        this._stub.purgeInstances.bind(this._stub),
        req,
        this._metadataGenerator,
      );
    } else {
      const purgeInstanceCriteria = value;
      const req = new pb.PurgeInstancesRequest();
      const filter = new pb.PurgeInstanceFilter();
      const createdTimeFrom = purgeInstanceCriteria.getCreatedTimeFrom();
      if (createdTimeFrom != undefined) {
        const timestamp = new Timestamp();
        timestamp.fromDate(createdTimeFrom);
        filter.setCreatedtimefrom(timestamp);
      }
      const createdTimeTo = purgeInstanceCriteria.getCreatedTimeTo();
      if (createdTimeTo != undefined) {
        const timestamp = new Timestamp();
        timestamp.fromDate(createdTimeTo);
        filter.setCreatedtimeto(timestamp);
      }
      const runtimeStatusList = purgeInstanceCriteria.getRuntimeStatusList();
      for (const status of runtimeStatusList) {
        filter.addRuntimestatus(toProtobuf(status));
      }
      req.setPurgeinstancefilter(filter);
      const timeout = purgeInstanceCriteria.getTimeout();

      console.log("Purging Instance using purging criteria");

      const callPromise = callWithMetadata<pb.PurgeInstancesRequest, pb.PurgeInstancesResponse>(
        this._stub.purgeInstances.bind(this._stub),
        req,
        this._metadataGenerator,
      );
      // Execute the request and wait for the first response or timeout
      res = (await Promise.race([
        callPromise,
        new Promise((_, reject) => setTimeout(() => reject(new TimeoutError()), timeout)),
      ])) as pb.PurgeInstancesResponse;
    }
    if (!res) {
      return;
    }
    return new PurgeResult(res.getDeletedinstancecount());
  }

  // ==================== Entity Methods ====================

  /**
   * Signals an entity to perform an operation.
   *
   * This method sends a one-way message to an entity, triggering the specified operation.
   * The method returns as soon as the message has been reliably enqueued; it does not
   * wait for the operation to be processed by the receiving entity.
   *
   * @param id - The ID of the entity to signal.
   * @param operationName - The name of the operation to invoke.
   * @param input - Optional input data for the operation.
   * @param options - Optional signal options (e.g., scheduled time).
   *
   * @remarks
   * Dotnet reference: DurableEntityClient.SignalEntityAsync
   */
  async signalEntity(
    id: EntityInstanceId,
    operationName: string,
    input?: unknown,
    options?: SignalEntityOptions,
  ): Promise<void> {
    const req = new pb.SignalEntityRequest();
    req.setInstanceid(id.toString());
    req.setRequestid(randomUUID());
    req.setName(operationName);

    if (input !== undefined) {
      const inputValue = new StringValue();
      inputValue.setValue(JSON.stringify(input));
      req.setInput(inputValue);
    }

    if (options?.signalTime) {
      const ts = new Timestamp();
      ts.fromDate(options.signalTime);
      req.setScheduledtime(ts);
    }

    const requestTime = new Timestamp();
    requestTime.fromDate(new Date());
    req.setRequesttime(requestTime);

    console.log(`Signaling entity '${id.toString()}' with operation '${operationName}'`);

    const prom = promisify(this._stub.signalEntity.bind(this._stub));
    await prom(req);
  }

  /**
   * Gets the metadata for an entity, optionally including its state.
   *
   * @param id - The ID of the entity to get.
   * @param includeState - Whether to include the entity's state in the response. Defaults to true.
   * @returns The entity metadata, or undefined if the entity does not exist.
   *
   * @remarks
   * Dotnet reference: DurableEntityClient.GetEntityAsync
   */
  async getEntity<T = unknown>(
    id: EntityInstanceId,
    includeState: boolean = true,
  ): Promise<EntityMetadata<T> | undefined> {
    const req = new pb.GetEntityRequest();
    req.setInstanceid(id.toString());
    req.setIncludestate(includeState);

    console.log(`Getting entity '${id.toString()}'`);

    const prom = promisify(this._stub.getEntity.bind(this._stub));
    const res = (await prom(req)) as pb.GetEntityResponse;

    if (!res.getExists()) {
      return undefined;
    }

    const protoMetadata = res.getEntity();
    if (!protoMetadata) {
      return undefined;
    }

    return this.convertEntityMetadata<T>(protoMetadata, includeState);
  }

  /**
   * Queries for entities matching the specified filter criteria.
   *
   * @param query - Optional query filter. If not provided, returns all entities.
   * @returns An async generator that yields entity metadata.
   *
   * @remarks
   * This method handles pagination automatically, fetching additional pages as needed.
   * Dotnet reference: DurableEntityClient.GetAllEntitiesAsync
   */
  async *getEntities<T = unknown>(query?: EntityQuery): AsyncGenerator<EntityMetadata<T>, void, unknown> {
    let continuationToken: string | undefined = query?.continuationToken;
    const includeState = query?.includeState ?? true;

    do {
      const req = new pb.QueryEntitiesRequest();
      const protoQuery = new pb.EntityQuery();

      if (query?.instanceIdStartsWith) {
        const prefix = new StringValue();
        prefix.setValue(query.instanceIdStartsWith);
        protoQuery.setInstanceidstartswith(prefix);
      }

      if (query?.lastModifiedFrom) {
        const ts = new Timestamp();
        ts.fromDate(query.lastModifiedFrom);
        protoQuery.setLastmodifiedfrom(ts);
      }

      if (query?.lastModifiedTo) {
        const ts = new Timestamp();
        ts.fromDate(query.lastModifiedTo);
        protoQuery.setLastmodifiedto(ts);
      }

      protoQuery.setIncludestate(includeState);
      protoQuery.setIncludetransient(query?.includeTransient ?? false);

      if (query?.pageSize) {
        const pageSize = new Int32Value();
        pageSize.setValue(query.pageSize);
        protoQuery.setPagesize(pageSize);
      }

      if (continuationToken) {
        const token = new StringValue();
        token.setValue(continuationToken);
        protoQuery.setContinuationtoken(token);
      }

      req.setQuery(protoQuery);

      const prom = promisify(this._stub.queryEntities.bind(this._stub));
      const res = (await prom(req)) as pb.QueryEntitiesResponse;

      const entities = res.getEntitiesList();
      for (const protoMetadata of entities) {
        yield this.convertEntityMetadata<T>(protoMetadata, includeState);
      }

      continuationToken = res.getContinuationtoken()?.getValue();
    } while (continuationToken);
  }

  /**
   * Cleans entity storage by removing empty entities and/or releasing orphaned locks.
   *
   * @param request - The clean request specifying what to clean. Defaults to removing empty entities and releasing orphaned locks.
   * @param continueUntilComplete - Whether to continue until all cleaning is done, or return after one batch.
   * @returns The result of the clean operation.
   *
   * @remarks
   * Dotnet reference: DurableEntityClient.CleanEntityStorageAsync
   */
  async cleanEntityStorage(
    request?: CleanEntityStorageRequest,
    continueUntilComplete: boolean = true,
  ): Promise<CleanEntityStorageResult> {
    const req = request ?? defaultCleanEntityStorageRequest();
    let continuationToken: string | undefined = req.continuationToken;
    let emptyEntitiesRemoved = 0;
    let orphanedLocksReleased = 0;

    do {
      const protoReq = new pb.CleanEntityStorageRequest();
      protoReq.setRemoveemptyentities(req.removeEmptyEntities);
      protoReq.setReleaseorphanedlocks(req.releaseOrphanedLocks);

      if (continuationToken) {
        const token = new StringValue();
        token.setValue(continuationToken);
        protoReq.setContinuationtoken(token);
      }

      const prom = promisify(this._stub.cleanEntityStorage.bind(this._stub));
      const res = (await prom(protoReq)) as pb.CleanEntityStorageResponse;

      continuationToken = res.getContinuationtoken()?.getValue();
      emptyEntitiesRemoved += res.getEmptyentitiesremoved();
      orphanedLocksReleased += res.getOrphanedlocksreleased();
    } while (continueUntilComplete && continuationToken);

    return {
      continuationToken,
      emptyEntitiesRemoved,
      orphanedLocksReleased,
    };
  }

  /**
   * Converts a protobuf EntityMetadata to a typed EntityMetadata.
   */
  private convertEntityMetadata<T>(protoMetadata: pb.EntityMetadata, includeState: boolean): EntityMetadata<T> {
    const instanceIdStr = protoMetadata.getInstanceid();
    const entityId = EntityInstanceId.fromString(instanceIdStr);

    const lastModifiedTime = protoMetadata.getLastmodifiedtime()?.toDate() ?? new Date();
    const backlogQueueSize = protoMetadata.getBacklogqueuesize();
    const lockedBy = protoMetadata.getLockedby()?.getValue();
    const serializedState = protoMetadata.getSerializedstate()?.getValue();

    if (includeState && serializedState) {
      const state = JSON.parse(serializedState) as T;
      return createEntityMetadata<T>(entityId, lastModifiedTime, backlogQueueSize, lockedBy, state);
    } else {
      return createEntityMetadataWithoutState(entityId, lastModifiedTime, backlogQueueSize, lockedBy) as EntityMetadata<T>;
    }
  }
}
